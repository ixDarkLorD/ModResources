apply plugin: "com.hypherionmc.modutils.modpublisher"

import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import java.util.regex.Pattern

import java.nio.file.Files
import java.nio.file.StandardCopyOption

tasks.register('buildInfo') {
    onlyIf { !project_loaders.split(",").contains(project.name) }
    doLast {
        printf("""
             |=============[Build Info]=============|
              Project Name: %s
              Version: %s
             |======================================|
             """, project.name, project.version)
    }
}

tasks.register('incrementBuildNumber') {
    onlyIf { project.hasProperty('copy_build_jar') }
    
    doLast {
        def jsonFileName = 'build_numbers.json'
        def jsonFile = new File(getRootDir(), jsonFileName)
        def tempFile = new File(getRootDir(), "${jsonFileName}.tmp")

        try {
            // Read or initialize JSON
            def json = [projects: [:]]
            if (jsonFile.exists()) {
                json = new groovy.json.JsonSlurper().parse(jsonFile)
                if (!json.projects) {
                    json.projects = [:]
                }
            }

            // Get or initialize project entry
            def projectName = project.name
            def currentBuild = (json.projects[projectName] ?: 0) as Integer
            def newBuild = currentBuild + 1
            json.projects[projectName] = newBuild
            
            // Atomic write using temp file
            tempFile.write(new groovy.json.JsonBuilder(json).toPrettyString())
            Files.move(
                tempFile.toPath(), 
                jsonFile.toPath(), 
                StandardCopyOption.REPLACE_EXISTING,
                StandardCopyOption.ATOMIC_MOVE
            )
            
            project.ext.buildNumber = newBuild
            
            println "\u001B[36m[INCREMENT]\u001B[0m ${projectName}: \u001B[1m${currentBuild} → ${newBuild}\u001B[0m"
            
        } catch (Exception e) {
            // Clean up temp file if something went wrong
            tempFile.delete()
            println "\u001B[31m[ERROR]\u001B[0m Failed to increment build number: ${e.message}"
            throw e
        }
    }
}

tasks.register('copyJarToDir', Copy) {
    dependsOn incrementBuildNumber
    
    onlyIf { 
        project.hasProperty('build_jar_output_dir') && 
        project.findProperty('copy_build_jar').toBoolean() 
    }
    
    doFirst {
        if (!project.hasProperty('buildNumber')) {
            throw new GradleException("Build number not available for ${project.name}")
        }
        println "\u001B[36m[COPY]\u001B[0m ${project.name} (build ${project.buildNumber})"
    }
    
    from(remapJar) {
        include '*.jar'
    }
    
    into(project.findProperty('build_jar_output_dir'))
    
    rename { fileName -> 
        def newName = fileName.replace("${mod_version}", "${mod_version}-build.${project.buildNumber}")
        println "\u001B[35m[RENAME]\u001B[0m ${fileName} → ${newName}"
        return newName
    }
    
    doLast {
        println "\u001B[32m[SUCCESS]\u001B[0m Copied ${project.name} (build ${project.buildNumber})"
    }
}

tasks.register('refreshUpdateJson') {
    onlyIf { project.loom.isForgeLike() && project.hasProperty('mod_resources') }
    doLast {
        def updateFile = file(project.findProperty('mod_resources').concat(File.separator).concat('updates').concat(File.separator).concat(project.name).concat(File.separator).concat("${modid}").concat('.json'))
        def updateJson
        if (updateFile.exists() && updateFile.canRead() && updateFile.length() != 0) {
            updateJson = new JsonSlurper().parseText(updateFile.text)
            "${project_game_versions}".replaceAll(" ", "").split(",").each { version ->
                updateJson['promos']["${version}-latest"] = "${mod_version}"
                // alpha and beta releases will contain 'a' or 'b' char respectively, don't update recommended for those
                if ("${mod_version}".matches("[^a-zA-Z]+")) {
                    updateJson['promos']["${version}-recommended"] = "${mod_version}"
                }
            }
        } else {
            updateFile.getParentFile().mkdirs()
            def builder = new JsonBuilder()
            updateJson = builder {
                homepage "${mod_page_url}"
                promos {
                    "${project_game_versions}".replaceAll(" ", "").split(",").each { version ->
                        "${version}-latest" "${mod_version}"
                        // alpha and beta releases will contain 'a' or 'b' char respectively, don't update recommended for those
                        if ("${mod_version}".matches("[^a-zA-Z]+")) {
                            "${version}-recommended" "${mod_version}"
                        }
                    }
                }
            }
        }
        def output = new JsonOutput()
        updateFile.write(output.prettyPrint(output.toJson(updateJson)))
    }
}

publisher {
    if (!project_loaders.contains(project.name))
        return

    if (!file("../CHANGELOG.md").canRead()) {
        throw new FileNotFoundException("Could not read changelog file")
    }

    // Enable Debug mode. When enabled, no files will actually be uploaded
    setDebug(Boolean.parseBoolean(project_upload_debug))

    apiKeys {
        if (!project_curse_id.isEmpty())
            curseforge curseforge_api_token

        if (!modrinth_api_token.isEmpty())
            modrinth modrinth_api_token
    }

    setCurseID(project_curse_id)
    setModrinthID(project_modrinth_id)
    setVersionType(project_release_type)
    setChangelog(file("../CHANGELOG.md"))

    setProjectVersion("${libs.versions.minecraft.get()}-${project.version}")
    setDisplayName("[${project.hasProperty("platform_name") ? project.findProperty("platform_name") : uppercaseFirstChar(project.name)}] ${project_game_versions.split(',').join(" - ")} | v${mod_version} " + uppercaseString("${project_release_type}"))
    setGameVersions(project_game_versions.split(','))
    setLoaders(project.name)
    setJavaVersions(libs.versions.java.get().split(','))
    setCurseEnvironment(mod_environment == "*" ? "both" : mod_environment)
    setIsManualRelease(false)
    setArtifact(remapJar)

    // Override the artifact uploaded to modrinth
    // setPlatformArtifact(Platform.Modrinth, "build/libs/mymod.jar")
    // setPlatformArtifact(Platform.Modrinth, jar.getArchiveFile().get())
    // If this is a task, the task specified will be executed before publishing
    // Valid platforms are modrinth, curseforge and github
    // setPlatformArtifact("modrinth", modrinthJar)

    // Disable the built in Fractureizer scanner
    setDisableMalwareScanner(false)

    // Safety check to check if the artifact contains a valid mod metadata entry,
    // which could possibly mean that the jar is empty
    setDisableEmptyJarCheck(true)

    String input = project.hasProperty(project.name + "_publish_dependencies")
            ? project.findProperty(project.name + "_publish_dependencies")
            : null
    List<String> result = extractDependencies(input, project.name)

    [curseDepends, modrinthDepends].each {
        if (!result[0].isEmpty()) {
            result[0].each { arg ->
                if (!arg.isBlank() && !arg.isEmpty()) 
                    it.required arg
            }
        }
        if (!result[1].isEmpty()) {
            result[1].each { arg ->
                if (!arg.isBlank() && !arg.isEmpty()) 
                    it.optional arg
            }
        }
    }
}

ext.helper = [
        getNextVersion: { version ->
            return getNextVersion(version as String)
        },
        getLatestVersion: { versions ->
            return getLatestVersion(versions as List<String>)
        },
        uppercaseFirstChar: { string ->
            return uppercaseFirstChar(string as String)
        },
        loaderNames: { return loaderNames() }
]

List<String> loaderNames() {
    return rootProject.project_loaders.split(",")
}

static String getNextVersion(String ver) {
    def versionMatcher = Pattern.compile("(\\d+\\.\\d+)").matcher(ver)
    versionMatcher.find()
    def currentVersion = versionMatcher.group(1)
    return currentVersion.substring(0, currentVersion.indexOf(".") + 1).concat(String.valueOf(Integer.parseInt(currentVersion.substring(currentVersion.indexOf(".") + 1, currentVersion.size())) + 1))
}

static String getLatestVersion(List<String> versions) {
    // Define the suffix priority list
    def suffixPriority = ["", "snapshot", "hotfix", "rc", "beta", "alpha"]

    def compareVersions = { String version1, String version2 ->
        def normalizeVersion = { String version ->
            // Normalize the version, separating suffix
            def mainVersion = version.replaceAll("[-_]", ".").replaceAll("([a-zA-Z])", '.$1')
            def parts = mainVersion.split(/\./).collect { it.isNumber() ? it.toInteger() : it.toString() }

            def suffix = parts[-1] instanceof String ? parts.pop() : ""
            return [parts, suffix]
        }

        def (parts1, suffix1) = normalizeVersion(version1)
        def (parts2, suffix2) = normalizeVersion(version2)

        // Compare main version numbers
        def maxLength = Math.max(parts1.size(), parts2.size())
        for (int i = 0; i < maxLength; i++) {
            def part1 = i < parts1.size() ? parts1[i] : 0
            def part2 = i < parts2.size() ? parts2[i] : 0
            if (part1 != part2) return part1 <=> part2
        }

        // Compare suffixes based on priority
        def suffixIndex1 = suffixPriority.indexOf(suffix1)
        def suffixIndex2 = suffixPriority.indexOf(suffix2)
        return suffixIndex1 <=> suffixIndex2
    }

    return versions.max { a, b -> compareVersions(a, b) }
}

static String uppercaseString(String str) {
    return str.toUpperCase()
}

static String uppercaseFirstChar(String str) {
    return str.substring(0, 1).toUpperCase() + str.substring(1)
}

static List<String> extractDependencies(String input, String projectName) {
    if (input == null)
        throw new IllegalStateException("There is no dependencies property for %s project".formatted(projectName))

    def requirementMatch = input =~ /requirement\[(.*?)]/
    def optionalMatch = input =~ /optional\[(.*?)]/

    def requirement = requirementMatch ? requirementMatch[0][1] : ""
    def optional = optionalMatch ? optionalMatch[0][1] : ""

    def requirementElements = requirement.split(',').collect { it.trim() }
    def optionalElements = optional.split(',').collect { it.trim() }

    // Convert elements to strings explicitly
    requirementElements = requirementElements.collect { it.toString() }
    optionalElements = optionalElements.collect { it.toString() }

    return [requirementElements, optionalElements] as List<String>
}